{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-15T00:27:11.107506+00:00",
  "repo": "Bren2010/draft-transparency-revocation",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDONGZggs60Y0sR",
      "title": "Downgrade Prevention",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/issues/2",
      "state": "OPEN",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The Poison Extension described in Section 8.1 and analyzed in 10.2 provides a limited form of downgrade protection. This protection relies on security of the legacy CT + revocation system and the propensity of each site operator to monitor for mis-issued certificates via the legacy CT ecosystem and have them revoked. \n\nIt is also limited to providing downgrade detection, rather than prevention, since there is necessarily a lag between when an unpoisoned certificate is used, when it is detected and when it is revoked, keeping in mind that such certificates fall outside the transparency and revocation system described in this draft. \n\nAs a contrast, using a HSTS-like mechanism where clients are preloaded with a list of sites supporting the new mechanism, or learn which sites want to enforce the new mechanism via a HTTP header, TLS extension field or certificate field, provides the stronger prevention property and does not depend on site operators or the legacy CT and revocation systems. \n\nHSTS mechanisms are not without their complications, but as this design already envisages keeping a substantial amount of state on clients including per-host PSKs in certain circumstances, the additional complexity seems low.",
      "createdAt": "2025-04-28T22:30:54Z",
      "updatedAt": "2025-04-30T12:56:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "In my conversations with Devon, he's expressed very strong opposition to \"another giant list of sites\". Also keep in mind: the legacy CT checks are only for protecting against malicious CAs, which is not the main concern with downgrades. The main concern is preventing an attacker from taking a revoked compromised certificate and avoiding revocation checks by using a downgraded protocol.",
          "createdAt": "2025-04-29T02:46:53Z",
          "updatedAt": "2025-04-29T02:47:35Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "COLLABORATOR",
          "body": "It's important to separate HSTS from HSTS-preload. The latter requires a list of websites, the former does not. \n\nI think the case for including a HSTS-like mechanism is rather strong, since we're storing a bunch of state anyway. Supporting a HSTS-preload mechanism is a much more nuanced decision, but it is also one that individual user agents can take for themselves. ",
          "createdAt": "2025-04-30T12:56:52Z",
          "updatedAt": "2025-04-30T12:56:52Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONGZggs60Y5oW",
      "title": "Document flow and reading order",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/issues/3",
      "state": "OPEN",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current document describes the transparency log and its structure first which involves shelling out to the KT drafts and getting the reader to deal with a lot of complexity up front. \n\nIt might be easier on the reader to reverse the current flow and proceed by entity. E.g. \n\n- Client Operation (connecting to a server, storing state)\n- Server Operation (getting a cert, serving a client\n- Log Operation (endpoints etc) \n\nI'm not sure how much to front-load or late-load the log structure. Perhaps having a short up front bit which introduces the main idea (e.g. the operations supported) and a later bit which actually specifies it? That implies leaving some of the operational bits abstract early on, but there's still plenty of complexity to dispatch up front (e.g. TLS Handshake flow). ",
      "createdAt": "2025-04-28T22:41:21Z",
      "updatedAt": "2025-04-28T22:41:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDONGZggs60Y9Zb",
      "title": "Roles of logs vs CAs (and ACME)",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/issues/4",
      "state": "OPEN",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft envisages that website operators interact directly with log operators, including PoP of the signing key of their leaf certificate and the use of a bearer token to authenticate future interactions. This is quite different from the existing WebPKI architecture, where websites interact with their CA and typically use an existing standard like ACME to do it.\n\nCondensing CAs and log operators into the same role, which implies that \"logging is issuance\" has a number of upsides: \n - Less complexity for website operators. \n - Certificates naturally live in a single log\n - The entity issuing certificates is also responsible for the bandwidth around their monitoring. \n - Logs don't need to grow at the rate of the WebPKI, they can instead grow at their own rate (e.g. throttling their own issuance to what their log can keep up with).\n\nBy itself, this would violate the current design goal of needing at least two colluding parties in order to defeat the transparency property, so would motivate the need for independent witnesses. ",
      "createdAt": "2025-04-28T22:51:26Z",
      "updatedAt": "2025-05-15T14:42:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "The purpose of separating CAs and logs was to allow site operators to refresh their inclusion (and revocation) proofs much more frequently than they can now. If your certificate can only be logged by a single party, then revocation can only be enforced as quickly as the longest conceivable outage of that single party (typically assumed to be 7 days). With separate CAs and logs, we can do 24 hour or faster revocation because if one log is down then you can fail over to another.",
          "createdAt": "2025-04-29T02:53:30Z",
          "updatedAt": "2025-04-29T02:54:23Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that surviving outages is vital but I'm not sure that having certs in multiple logs is the right way to achieve that because it has some implications. This is a bit of a raw chain of thought, to help refine my own thinking as much as to communicate it. \n\n**When can a cert be considered revoked?**\n\n - A certificate is not revoked until it is revoked in every log. Consider a certificate which has been compromised. The owner can submit a revocation statement to their log. However, the attacker can also submit an inclusion request to a new log. Even if the owner later submits a revocation statement, the initial tree-head with the valid cert will reset the deadline for when clients will stop trusting the compromised certificate.\n\n - To avoid this, every log needs to have every revocation statement. Further, to enforce a maximum window for revocation, every log needs to have every revocation statement 'soon'. This suggests that all revocation logs need to run at the speed of the WebPKI and need to keep up. Blowing a MMD in a CT log is only a problem if you've issued unincorporated SCTs. Here, if you include a new cert but you're behind on revocations, it's a risk of effectively unrevoking a revoked cert (an 'unrevocation'). \n\n- It's possible this could be managed outside of the log itself, e.g. with logs promising to scrape CRLs and using them to reject new submissions, but then correct behavior becomes hard to verify and we're losing transparency. \n\n- Maybe there's a way through this without having to have logs keep up? I don't see one without compromising a lot on transparency. **However, if there's a good off-ramp here, the following analysis might be misplaced.** \n\n**Spare capacity and horizontal scaling**\n\n - Having site operators be able to submit their certs to multiple logs to recover from a log falling over is one part of the design, but the other log operators also need to be able to absorb the additional load. \n\n- In a system where all logs need to accept all certificates to avoid 'unrevocations', there's no horizontal scaling from adding more logs. Instead, the spare capacity of the system is min( log_capacity - log_usage ) over each log, which means that making the slowest log faster is the only way to add capacity. \n\n- The net effect though is to push the system towards a small number of chunky logs operated by players big enough to deliver high quality / high scalability systems. I don't think there's an effective way for smaller players to contribute to the capacity of the system.\n\n- It's also a problem as traffic grows over time, requiring continuous investment to ensure that the slowest log implementation / instantiation can keep up. \n\n- These scaling properties are similar to the CT logs we have today. This makes for a pretty fragile ecosystem.\n\n- On plus side, this does mean that the load that needs to be absorbed by other logs after a log failure is fairly small so cascades are less likely to be an issue. The  others logs must already be processing everything in the system, so the only change is some additional egress bandwidth to communicate the tree heads to the new websites using the log. However, this can still be an issue in real world systems, where a log which was keeping up but not directly serving websites, is now being hit by a lot more traffic. \n\n**Sharding logs** \n\n- Getting some horizontal scaling back means being able to shard logs so that not every certificate is in every log. \n\n- At the extreme end, that's one log per certificate (e.g. the CA). Failover is then handled by getting a new certificate. \n\n- CA's can host multiple logs to provide transparent failover. In rare circumstances, websites might need to failover to another CA. This also creates a natural market for unreliable CAs.\n\n- Aligning logs with CAs also means that capacity is easier to manage. Smaller players can run smaller logs, in the knowledge that they never intend to issue say 50% of the WebPKI tomorrow. This leads to much healthier ecosystem and overall greater net capacity. \n\n- It's also easier to build in spare capacity, because each participating log is only using up its own capacity, so necessarily has plenty of headroom. \n\n**Aside: Alternative concepts of revocation**\n\n- This isn't directly related, but just musing on different options for how clients can enforce revocation. \n- Client's can differ in how stale a tree head they tolerate before they consider it equivalent to revoked. If a client is aware of a more recent tree head, that could influence a client's tolerance. (E.g. I tolerate no more than 3 days behind the tree head I have, or up to 7 days otherwise). \n- CA's can also embed policy in certificates around maximum-staleness. Browsers will still want to enforce limits here, but it doesn't have to be one size fits all. This might also lead to differentiation in choice of CA, which goes some way towards rewarding less downtime. ",
          "createdAt": "2025-05-01T15:44:45Z",
          "updatedAt": "2025-05-01T15:44:45Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "> This suggests that all revocation logs need to run at the speed of the WebPKI and need to keep up.\n\nEvery log does not need to keep up with the issuance rate of the webPKI. They just need to be aware of all revocations, which are much less frequent. Most revocations that a log becomes aware of will never warrant the log actually doing anything unless the certificate is submitted (in which case it needs to reject or log as marked revoked).\n\n> It's possible this could be managed outside of the log itself, e.g. with logs promising to scrape CRLs and using them to reject new submissions, but then correct behavior becomes hard to verify and we're losing transparency.\n\nHow are we losing transparency? Site operators can still see perfectly well what acceptable certificates exist for their domains. If a Transparency Log doesn't mark a certificate as revoked when it should be, that's very obvious.\n\n> Getting some horizontal scaling back means being able to shard logs so that not every certificate is in every log.\n\nThe document is already designed to be sharded such that certificates never need to be logged multiple times unless a log has an outage.\n\n",
          "createdAt": "2025-05-01T16:14:50Z",
          "updatedAt": "2025-05-01T16:14:50Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "COLLABORATOR",
          "body": "**Part 1: Log Ingestion** \n\nAs you pointed out and we discussed, there's no need for every log to have every certificate, but we do need to know that every log that would in theory accept a given certificate would refuse to. This is allowed purely for policy reasons, e.g. a log that only wishes to serve a subset of CAs, but is also required if the certificate in question has been revoked and not yet submitted to the log. We expect that CAs will provision TLS servers with a list of suitable logs, we don't expect subscribers to have individual relationships with particular logs. \n\n**TODO(djackson)** Clarify these operational aspects in the text. \n\n**Part 2: Revocation 'Transparency'**\n\nI described this setup as missing out on some transparency, but I think it would be more proper to describe it as missing some accountability. Existing CT log operators were intended to be trustless - insofar as the intention was to be able to externally measure whether they were doing a good job and so hold them accountable accordingly. \n\nIn this draft/system, we have CAs that revoke a certificate by adding it to a signed CRL. Log operators then need to consume the CRL so they know not to accept any revoked certificates (if they did, it would have the effect of unrevoking the cert). However, it is possible for a CA to present different views of a CRL to two different log operators. If this happens, we'd have no easy to determine whether the CA or the log was to blame. \n\nI don't know that we necessarily need to fix the accountability as part of this solution, we could instead migrate each CRL to be an append-only log, but having some accountable ground-truth for when a certificate was first revoked would be valuable. ",
          "createdAt": "2025-05-15T14:42:05Z",
          "updatedAt": "2025-05-15T14:42:55Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDONGZggs60Y_b1",
      "title": "Delayed Issuance Optimization",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/issues/5",
      "state": "OPEN",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A large fraction of WebPKI issuances are renewals of existing certificates, typically carried out well in advance of the actual expiry of the certificate. This can be leveraged to optimize server bandwidth further by obtaining a renewed certificate in advance, then waiting a period of time before switching to serving connections with it. \n\nThis delay improves the probability that clients have already seen the necessary tree heads, especially if there's an alternative mechanism for distributing tree heads to some clients. ",
      "createdAt": "2025-04-28T22:56:24Z",
      "updatedAt": "2025-04-30T12:50:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "I agree with this but the protocol already supports it as written. Is there a change to the text that you had in mind?",
          "createdAt": "2025-04-29T02:55:31Z",
          "updatedAt": "2025-04-29T02:55:31Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "COLLABORATOR",
          "body": "My thought was to explain this explicitly in Performance Considerations. Should be a fairly small PR but I didn't want it to get lost. ",
          "createdAt": "2025-04-30T12:50:10Z",
          "updatedAt": "2025-04-30T12:50:10Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDONGZggs62xdoS",
      "title": "Branch for supporting SANs",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/issues/6",
      "state": "OPEN",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Re: [brendan/feeback](https://github.com/Bren2010/draft-transparency-revocation/compare/main...brendan/feedback) branch. \n\n(Opening this to put the feedback somewhere durable and isolated) \n\nIt looks reasonable at first glance, but I still need to spend some more time with how the monitoring of this actually works. Some minor thoughts that came to me during my readthrough: \n\n- The new key scheme for the prefix tree is very similar to the one I considered for Starlit Jellyfish. I think its possible for an attacker to register domains which share prefixes of a target domain in order to make path lengths longer by registering domains with common prefixes of popular domains. I haven't thought through how severe the impact actually is as to whether its worth doing, but it could be mitigated if each component in a domain was hashed and the result concatenated (e.g. `h(com)||h(facebook)||h(www)`)\n\n- I haven't reread the BRs lately but I don't think the number of SANs in a certificate is bounded. 256 is probably a reasonable practical limit but right now you can put 1000 or 10,000 SANs in a certificate if you so wish (bounded by the maximums size of a cert chain in TLS). \n\n- Fwiw [Certificate Frames](https://httpwg.org/http-extensions/draft-ietf-httpbis-secondary-server-certs.html) and [Origin Frames](https://httpwg.org/specs/rfc9412.html) are attempts to make connection coalescing work without the need to create a single TLS cert which covers all the coalesced domains. But not sure they'll ever be widely deployed enough to be a true solution.  ",
      "createdAt": "2025-05-15T14:20:57Z",
      "updatedAt": "2025-05-15T16:35:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "body": "> The new key scheme for the prefix tree is very similar to the one I considered for Starlit Jellyfish. I think its possible for an attacker to register domains which share prefixes of a target domain in order to make path lengths longer by registering domains with common prefixes of popular domains.\n\nYes, this is an issue with the text as written. The paths forward that I see here are either adding a full description of a balanced prefix tree to this draft, or arguing for balancing the prefix tree in KT.",
          "createdAt": "2025-05-15T16:35:55Z",
          "updatedAt": "2025-05-15T16:35:55Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDONGZggs6UMhsf",
      "title": "Front matter",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/pull/1",
      "state": "MERGED",
      "author": "dennisjackson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Sharpens the discussion around revocation and shorter lifetimes. Teases KT in the intro. ",
      "createdAt": "2025-04-28T16:13:14Z",
      "updatedAt": "2025-05-09T02:02:20Z",
      "baseRepository": "Bren2010/draft-transparency-revocation",
      "baseRefName": "main",
      "baseRefOid": "ad39b6aa235c16796278435963b64b91ada61c0b",
      "headRepository": "Bren2010/draft-transparency-revocation",
      "headRefName": "intro",
      "headRefOid": "e11bf0d4798199c7e70299e5716cdf03db815c78",
      "closedAt": "2025-05-09T02:02:20Z",
      "mergedAt": "2025-05-09T02:02:20Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "83b43a8d28c8c0c11e7300e210154663a14a52d0"
      },
      "comments": [
        {
          "author": "dennisjackson",
          "authorAssociation": "COLLABORATOR",
          "body": "(I think Github got rid of draft PRs for non-enterprise users, but treat this as a draft for now.)",
          "createdAt": "2025-04-28T16:22:00Z",
          "updatedAt": "2025-04-28T16:22:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONGZggs6m9E_c",
          "commit": {
            "abbreviatedOid": "06deb87"
          },
          "author": "Bren2010",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-28T21:32:51Z",
          "updatedAt": "2025-04-28T21:37:14Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nMore recent alternatives like CRLSets {{CRLSets}}, CRLite {{CRLite}}, and\r\n```",
              "createdAt": "2025-04-28T21:32:52Z",
              "updatedAt": "2025-04-28T21:37:14Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nthe number of logs active, and the number of interested monitors.\r\n```",
              "createdAt": "2025-04-28T21:32:59Z",
              "updatedAt": "2025-04-28T21:37:14Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\nyears, Key Transparency systems have been deployed by Apple {{AppleKT}}, Meta\r\n```",
              "createdAt": "2025-04-28T21:33:47Z",
              "updatedAt": "2025-04-28T21:37:14Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n{{MetaKT}}, and ProtonMail {{ProtonKT}}. These systems not only provide stronger\r\n```",
              "createdAt": "2025-04-28T21:34:03Z",
              "updatedAt": "2025-04-28T21:37:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDONGZggs6aJJTR",
      "title": "Brendan/feedback",
      "url": "https://github.com/Bren2010/draft-transparency-revocation/pull/7",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-12T05:16:29Z",
      "updatedAt": "2025-06-12T05:16:39Z",
      "baseRepository": "Bren2010/draft-transparency-revocation",
      "baseRefName": "main",
      "baseRefOid": "83b43a8d28c8c0c11e7300e210154663a14a52d0",
      "headRepository": "Bren2010/draft-transparency-revocation",
      "headRefName": "brendan/feedback",
      "headRefOid": "0678519bce9d3e058e70ab14281e4ea63aef1c6a",
      "closedAt": "2025-06-12T05:16:38Z",
      "mergedAt": "2025-06-12T05:16:38Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "754d455c53a74499b3dd5349ffb9527e70236e7e"
      },
      "comments": [],
      "reviews": []
    }
  ]
}